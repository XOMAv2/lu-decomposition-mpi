# Задание 23.

Разработать программу вычисления LU-разложения заданной матрицы.

Объяснить проектное решение (выбор алгоритма).
Обеспечить равномерную загрузку процессоров.
Результат вывести в текстовый файл.
Исследовать зависимость времени счёта от размерности задачи и количества процессоров.

# Зависимости

```zsh
brew install mpich
```

# Запуск

## На одном процессоре

```zsh
make clean
```
```zsh
make
```
```zsh
mpiexec -n 4 ./lu_decomposition 5 true
```
```zsh
mpiexec -n 4 ./lu_decomposition 2000
```

## На нескольких процессорах

```zsh
make clean
```
```zsh
make
```
```zsh
sbatch ./job.sh
```
```zsh
squeue
```
```zsh
scancel 1995
```

# Алгоритм

## Последовательный

```c
/*
 * A = |  2    4   -4 |                          L = |   1   0   0 |
 *     |{ 1}  -4    3 | // R_1 - (1 / 2) * R_0       | 0.5   1   0 |
 *     | -6   -9    5 |                              |   X   X   1 |
 *
 * A = |  2    4   -4 |                           L = |   1   0   0 |
 *     |  0   -6    5 |                               | 0.5   1   0 |
 *     |{-6}  -9    5 | // R_2 - (-6 / 2) * R_0       |  -3   X   1 |
 *
 * A = |  2    4   -4 |                           L = |    1    0    0 |
 *     |  0   -6    5 |                               |  0.5    1    0 |
 *     |  0  { 3}  -7 | // R_2 - (3 / -6) * R_1       |   -3 -0.5    1 |
 *
 * U = |    2      4     -4 |   LU = |    2      4     -4 |
 *     |    0     -6      5 |        |  0.5     -6      5 |
 *     |    0      0   -4.5 |        |   -3   -0.5   -4.5 |
 */
```

## Параллельный (MPI)

### Original (реализация в лоб) (очень много времени тратится на пересылку сообщений при запуске на нескольких машинах)

Внешний цикл - по колонкам, внутренний - по строком.

На каждой итерации внешнего распределяем равное число строк на каждый процессор.

Простой способ - `row_count % processor_count`, сложный - разделить строки на диапазоны и отдать процессору диапазон целиком. Зачем? Чтобы при широковещании результатов (`MPI_Bcast`) передавать за раз диапазон целиком, а не синзронизироваться на каждую строку.

### Chunk

Матрицу делим на n чанков, по одному на каждый процессор. Каждый процессор рассчитывает свой чанк (непрерывная область строк), а потом бродкастит результат остальным. При шаге по колонкам размер чанка пересчитываем.

### Optimise

Делим матрицу на n диапазонов, где n - количество процессоров. Каждый процессор расчитывает строки внутри своего диапазона. Бродкастится только та строка, которая необходимо для расчёта всех остальных строк на текущем шаге по колонкам.

Самый эффективный вариант, но не обеспечивает равномерную загрузку процессоров. Вариант решения - переодически пересчитывать размер диапазанов для обеспечения равномерной загрузки.
